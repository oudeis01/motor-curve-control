<!DOCTYPE html>
<html>

<head>
    <title>Motor Curve Generator</title>
    <style>
        /* Keep all existing CSS styles unchanged */
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #timeScale {
            width: 300px;
            margin: 20px;
            background: #333;
        }
        .container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        button {
            padding: 10px;
            margin: 10px;
            cursor: pointer;
            background-color: #2d2d2d;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #3d3d3d;
        }
        #chartContainer {
            position: relative;
            margin: 20px;
            width: calc(100% - 40px);
            max-width: 100%;
            overflow: hidden;
            box-sizing: border-box;
            height: 400px;
            border: 1px solid #444;
            margin-top: 40px;
            background-color: #222;
            padding: 20px 40px 60px 60px; /* Add space for x-axis labels and name */
            padding-bottom: 80px; /* Add more space for x-axis gradation labels */
            padding-right: 20px; /* Add padding to the right to prevent cutoff */
            margin-right: 30px;
        }
        #myChart {
            width: 100%;
            height: 100%;
        }
        .control-section {
            margin: 20px;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 5px;
            background: #2d2d2d;
        }
        .control-group {
            margin: 15px 0;
            padding: 10px;
            border-bottom: 1px solid #3d3d3d;
        }
        input[type="number"] {
            width: 80px;
            margin-right: 15px;
            padding: 5px;
            background-color: #333;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
        }
        #genNotification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            display: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .lang-selector {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        #languageSelect {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #2d2d2d;
            color: #fff;
            font-size: 14px;
        }
        .axis-label {
            position: absolute;
            color: #666;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #x-axis-label {
            bottom: 30px; /* Move below the gradation labels */
            left: 50%;
            transform: translateX(-50%);
        }
        #y-axis-label {
            top: 50%;
            left: 10px;
            transform: translateY(-50%) rotate(-90deg);
        }
        input[type="range"]::-webkit-slider-thumb {
            background: #666;
        }
        input[type="checkbox"] {
            accent-color: #666;
        }
    </style>
</head>

<body>
    <div class="lang-selector">
        <select id="languageSelect" onchange="changeLanguage(this.value)">
            <option value="ko">한국어</option>
            <option value="zh">中文</option>
            <option value="en">English</option>
        </select>
    </div>
    <div class="container">
        <div id="chartContainer">
            <div class="axis-label" id="x-axis-label">Time (sec)</div>
            <div class="axis-label" id="y-axis-label">Speed (%)</div>
            <canvas id="myChart"></canvas>
        </div>
        <div class="control-section">
            <div class="control-group">
                <label data-i18n="timeScale">Time Scale: </label>
                <input type="range" id="timeScale" min="1" max="10" value="1" step="0.1">
                <span id="scaleValue">1x</span>
            </div>

            <div class="control-group">
                <button onclick="generateCode()" data-i18n="generateCode">Generate Arduino Code</button>
                <button onclick="resetChart()" data-i18n="resetChart">Reset Chart</button>
            </div>

            <div class="control-group">
                <h3 data-i18n="sineWave">Sine Wave Generator</h3>
                <label data-i18n="amplitude">Amplitude (%): </label>
                <input type="number" id="sineAmplitude" min="0" max="100" value="50">
                <label data-i18n="frequency">Frequency (Hz): </label>
                <input type="number" id="sineFrequency" min="0.1" max="10" step="0.1" value="1">
                <br>
                <label>
                    <input type="checkbox" id="appendWave">
                    <span data-i18n="appendWave">Append to last point</span>
                </label>
                <button onclick="generateSineWave()" data-i18n="generateWave">Generate Sine Wave</button>
            </div>
        </div>
    </div>
    <div id="genNotification"></div>
    <script>
        // Increase right margin to make space for the last section
        const CHART_MARGIN = { left: 50, right: 80, top: 20, bottom: 40 };
        let dataPoints = [];
        let timeScale = 1;
        let canvas, ctx;
        let isDragging = false;
        let selectedPointIndex = -1;
        const pointRadius = 5;
        const gridColor = '#3d3d3d';
        const axisColor = '#666';
        const pointColor = '#ff4444';
        const lineColor = '#4a90e2';
        let devicePixelRatio = 1;

        // Language configuration
        const i18n = {
            'en': {
                'timeScale': 'Time Scale: ',
                'generateCode': 'Generate Arduino Code',
                'resetChart': 'Reset Chart',
                'sineWave': 'Sine Wave Generator',
                'amplitude': 'Amplitude (%): ',
                'frequency': 'Frequency (Hz): ',
                'appendWave': 'Append to last point',
                'generateWave': 'Generate Sine Wave',
                'fileGenerated': 'File generated: ',
                'alertPoints': 'Please create some points first!'
            },
            'zh': {
                'timeScale': '时间比例: ',
                'generateCode': '生成Arduino代码',
                'resetChart': '重置图表',
                'sineWave': '正弦波生成器',
                'amplitude': '幅度(%): ',
                'frequency': '频率(Hz): ',
                'appendWave': '追加到最后一点',
                'generateWave': '生成正弦波',
                'fileGenerated': '文件已生成: ',
                'alertPoints': '请先创建一些数据点!'
            },
            'ko': {
                'timeScale': '시간 축척: ',
                'generateCode': '아두이노 코드 생성',
                'resetChart': '차트 리셋',
                'sineWave': '사인파 생성기',
                'amplitude': '진폭(%): ',
                'frequency': '주파수(Hz): ',
                'appendWave': '마지막 지점에 추가',
                'generateWave': '사인파 생성',
                'fileGenerated': '파일 생성됨: ',
                'alertPoints': '먼저 점을 생성해 주세요!'
            }
        };

        let currentLang = localStorage.getItem('appLang') || 'ko';

        function changeLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = i18n[lang][key];
            });
            document.getElementById('languageSelect').value = lang;

            // Update axis labels dynamically
            document.getElementById('x-axis-label').textContent = i18n[lang]['timeScale'].includes('Time') ? 'Time (sec)' : lang === 'zh' ? '时间 (秒)' : '시간 (초)';
            document.getElementById('y-axis-label').textContent = i18n[lang]['timeScale'].includes('Time') ? 'Speed (%)' : lang === 'zh' ? '速度 (%)' : '속도 (%)';

            drawChart();
        }

        function initChart() {
            canvas = document.getElementById('myChart');
            ctx = canvas.getContext('2d');
            const container = document.getElementById('chartContainer');

            // Handle device pixel ratio
            devicePixelRatio = window.devicePixelRatio || 1;
            const containerWidth = container.clientWidth - 100; // Increased margin to prevent cutoff
            const containerHeight = 400;

            // Set canvas dimensions
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerHeight + 'px';
            canvas.width = containerWidth * devicePixelRatio;
            canvas.height = containerHeight * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);

            // Event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);

            window.addEventListener('resize', () => {
                const container = document.getElementById('chartContainer');
                canvas.style.width = container.clientWidth + 'px';
                canvas.width = container.clientWidth * devicePixelRatio;
                ctx.scale(devicePixelRatio, devicePixelRatio);
                drawChart();
            });

            changeLanguage(currentLang);
            drawChart();
        }

        function drawChart() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawAxisLabels();
            drawDataPoints();
            drawLine();
        }

        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 0.5;

            // Vertical grid lines
            for (let x = 0; x <= timeScale; x += 0.1) {
                const screenX = xToScreen(x);
                ctx.beginPath();
                ctx.moveTo(screenX, CHART_MARGIN.top);
                ctx.lineTo(screenX, canvas.height/devicePixelRatio - CHART_MARGIN.bottom);
                ctx.stroke();
            }

            // Horizontal grid lines
            for (let y = 0; y <= 100; y += 10) {
                const screenY = yToScreen(y);
                ctx.beginPath();
                ctx.moveTo(CHART_MARGIN.left, screenY);
                ctx.lineTo(canvas.width/devicePixelRatio - CHART_MARGIN.right, screenY);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 1;

            // X axis
            ctx.beginPath();
            ctx.moveTo(CHART_MARGIN.left, canvas.height/devicePixelRatio - CHART_MARGIN.bottom);
            ctx.lineTo(canvas.width/devicePixelRatio - CHART_MARGIN.right, canvas.height/devicePixelRatio - CHART_MARGIN.bottom);
            ctx.stroke();

            // Y axis
            ctx.beginPath();
            ctx.moveTo(CHART_MARGIN.left, CHART_MARGIN.top);
            ctx.lineTo(CHART_MARGIN.left, canvas.height/devicePixelRatio - CHART_MARGIN.bottom);
            ctx.stroke();
        }

        function drawAxisLabels() {
            ctx.fillStyle = axisColor;
            ctx.font = '12px Arial';

            // X-axis labels - with dynamic density based on time scale
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Calculate appropriate step size based on time scale
            let xStep = 0.1;
            if (timeScale > 1 && timeScale <= 2) xStep = 0.2;
            else if (timeScale > 2 && timeScale <= 4) xStep = 0.5;
            else if (timeScale > 4 && timeScale <= 6) xStep = 1.0;
            else if (timeScale > 6) xStep = Math.ceil(timeScale / 6);
            
            for (let x = 0; x <= timeScale; x += xStep) {
                const screenX = xToScreen(x);
                if (screenX > CHART_MARGIN.left && screenX < canvas.width / devicePixelRatio - CHART_MARGIN.right) {
                    ctx.fillText(x.toFixed(1), screenX, canvas.height / devicePixelRatio - CHART_MARGIN.bottom + 5);
                }
            }

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = 0; y <= 100; y += 10) {
                const screenY = yToScreen(y);
                if (screenY > CHART_MARGIN.top && screenY < canvas.height / devicePixelRatio - CHART_MARGIN.bottom) {
                    ctx.fillText(y + '%', CHART_MARGIN.left - 10, screenY);
                }
            }
        }

        function drawDataPoints() {
            dataPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(xToScreen(point.x), yToScreen(point.y), pointRadius, 0, Math.PI * 2);
                ctx.fillStyle = pointColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.stroke();
            });
        }

        function drawLine() {
            if (dataPoints.length < 2) return;

            ctx.beginPath();
            ctx.moveTo(xToScreen(dataPoints[0].x), yToScreen(dataPoints[0].y));
            dataPoints.slice(1).forEach(point => {
                ctx.lineTo(xToScreen(point.x), yToScreen(point.y));
            });
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function xToScreen(x) {
            const availableWidth = (canvas.width / devicePixelRatio) - CHART_MARGIN.left - CHART_MARGIN.right - 20; // Added additional padding
            return CHART_MARGIN.left + (x / timeScale) * availableWidth;
        }

        function yToScreen(y) {
            const availableHeight = canvas.height/devicePixelRatio - CHART_MARGIN.top - CHART_MARGIN.bottom;
            return CHART_MARGIN.top + availableHeight - (y / 100) * availableHeight;
        }

        function screenToX(screenX) {
            const availableWidth = canvas.width/devicePixelRatio - CHART_MARGIN.left - CHART_MARGIN.right;
            return ((screenX - CHART_MARGIN.left) / availableWidth) * timeScale;
        }

        function screenToY(screenY) {
            const availableHeight = canvas.height/devicePixelRatio - CHART_MARGIN.top - CHART_MARGIN.bottom;
            return ((availableHeight - (screenY - CHART_MARGIN.top)) / availableHeight) * 100;
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width/devicePixelRatio / rect.width;
            const scaleY = canvas.height/devicePixelRatio / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            selectedPointIndex = findNearestPoint(x, y);

            if (selectedPointIndex === -1) {
                const newX = Math.max(0, Math.min(screenToX(x), timeScale));
                const newY = Math.max(0, Math.min(screenToY(y), 100));

                dataPoints.push({ x: newX, y: newY });
                dataPoints.sort((a, b) => a.x - b.x);
                drawChart();
            } else {
                isDragging = true;
            }
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width/devicePixelRatio / rect.width;
            const scaleY = canvas.height/devicePixelRatio / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const newX = Math.max(0, Math.min(screenToX(x), timeScale));
            const newY = Math.max(0, Math.min(screenToY(y), 100));

            dataPoints[selectedPointIndex] = { x: newX, y: newY };
            dataPoints.sort((a, b) => a.x - b.x);
            selectedPointIndex = dataPoints.findIndex(p => p.x === newX && p.y === newY);
            drawChart();
        }

        function handleMouseUp() {
            isDragging = false;
            selectedPointIndex = -1;
        }

        function handleDoubleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width/devicePixelRatio / rect.width;
            const scaleY = canvas.height/devicePixelRatio / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const index = findNearestPoint(x, y);
            if (index !== -1 && distance(x, y, xToScreen(dataPoints[index].x), yToScreen(dataPoints[index].y)) < 15) {
                dataPoints.splice(index, 1);
                drawChart();
            }
        }

        function findNearestPoint(x, y) {
            let minDist = Infinity;
            let foundIndex = -1;

            dataPoints.forEach((point, index) => {
                const pointX = xToScreen(point.x);
                const pointY = yToScreen(point.y);
                const dx = x - pointX;
                const dy = y - pointY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 15 && dist < minDist) {
                    minDist = dist;
                    foundIndex = index;
                }
            });

            return foundIndex;
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function generateSineWave() {
            const amplitude = parseFloat(document.getElementById('sineAmplitude').value);
            const frequency = parseFloat(document.getElementById('sineFrequency').value);
            const append = document.getElementById('appendWave').checked;

            const startX = append && dataPoints.length > 0
                ? dataPoints[dataPoints.length - 1].x
                : 0;
            const duration = timeScale - startX;

            const points = [];
            for (let t = 0; t <= duration; t += 0.02) {
                const x = startX + t;
                const y = 50 + amplitude * Math.sin(2 * Math.PI * frequency * t);
                points.push({ x: x, y: y });
            }

            dataPoints = dataPoints.filter(p => p.x < startX).concat(points);
            drawChart();
        }

        function resetChart() {
            dataPoints = [];
            drawChart();
        }

        function generateCode() {
            if (dataPoints.length === 0) {
                alert(i18n[currentLang]['alertPoints']);
                return;
            }

            const sortedPoints = [...dataPoints].sort((a, b) => a.x - b.x);

            let code = `#include <math.h>\n\n`;
            code += `const int NUM_POINTS = ${sortedPoints.length};\n`;
            code += `float timePoints[NUM_POINTS] = {${sortedPoints.map(p => p.x.toFixed(2)).join(', ')}};\n`;
            code += `float values[NUM_POINTS] = {${sortedPoints.map(p => p.y.toFixed(2)).join(', ')}};\n\n`;

            code += `void setup() {\n`;
            code += `  pinMode(10, OUTPUT);\n\n`;
            code += `  TCCR1A = _BV(COM1A1) | _BV(WGM10);\n`;
            code += `  TCCR1B = _BV(CS10);\n`;
            code += `}\n\n`;
            code += `void loop() {\n`;
            code += `  float currentTime = millis() / 1000.0;\n`;
            code += `  float outputValue = 0.0;\n\n`;
            code += `  for(int i = 0; i < NUM_POINTS - 1; i++) {\n`;
            code += `    if(currentTime >= timePoints[i] && currentTime <= timePoints[i+1]) {\n`;
            code += `      float t = (currentTime - timePoints[i]) / (timePoints[i+1] - timePoints[i]);\n`;
            code += `      outputValue = values[i] + t * (values[i+1] - values[i]);\n`;
            code += `      break;\n    }\n  }\n\n`;
            code += `  int pwmValue = constrain(outputValue * 2.55, 0, 255);\n`;
            code += `  analogWrite(10, pwmValue);\n`;
            code += `  delay(10);\n`;
            code += `}\n`;

            window.electronAPI.saveCode(code).then(filename => {
                const notification = document.getElementById('genNotification');
                if (filename) {
                    notification.textContent = `${i18n[currentLang]['fileGenerated']} ${filename.displayPath}`; // Fix popup text
                    notification.style.display = 'block';
                    setTimeout(() => notification.style.display = 'none', 1000);
                }
            });
        }

        document.getElementById('timeScale').addEventListener('input', (e) => {
            timeScale = parseFloat(e.target.value);
            document.getElementById('scaleValue').textContent = `${timeScale}x`;
            drawChart();
        });

        window.onload = initChart;
    </script>
</body>
</html>